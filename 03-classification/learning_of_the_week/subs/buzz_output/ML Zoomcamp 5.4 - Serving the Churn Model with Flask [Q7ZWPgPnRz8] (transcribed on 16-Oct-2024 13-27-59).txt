Welcome back, this is lesson 4 of Machine Learning Zoom Camp session 5, and in this lesson we will talk about serving the churn model with Flask. Previously we created a script for saving a model, for training a model and saving it to a pickle file, and we also talked, already talked about Flask and creating a simple web service with Flask. So in this lesson we will put this together and we will take our predict script that we have and turn it into a web service. So let's start. What we want to do is we want to create a web service, let's call it churn service. So this service has our model, 

right, and we want this model to be available at slash predict root, and then let's say we have our marketing service here, so they will send us some information about customers, so it will look exactly like that. All the information we know about the customers, and then we will reply them with basically this probability of churning. This is what we want to do. We want to create a predict method and then put it to the slash predict address. So let's do that. So we have this function we'll call predict. So this function meets a customer, and then we simply return the predictions. So this is what we want to now turn into a web service. So let me remove the customer for a while. We'll just create a different file. So what we need here now is, let me remove that. So let me open this other file with our web service and just copy everything. I'll put it here. So let's add Flask. Let's put the import here at the top, and then we'll create a Flask app. Let's do it here. We can call the app churn, and we want to put it to the root predict, and instead of using the get method, we'll use here post. So the reason for that is because we want to send some information about the customer, and we cannot easily do it with a get method. So let me remove this pink method here, pink function. When we send this information, this information will be sent in JSON format. So the request, the body of the request will contain the features, the information about the customer in JSON format, and the response will also be JSON. And JSON looks exactly like Python dictionaries, except here instead of single quotes, we use usual quotes. So let me just quickly replace it. So now this is a JSON document that contains some fields. So for each field, it contains values. This is JSON. And this is what we want to send to our web service. And unfortunately, in Flask, it's not as easy as that. So here we need to tell Flask that we are getting JSON, and we want to extract the body of the request as JSON. So for that, we need to import special helper function from Flask called special helper utility from Flask called request. And this request contains the information about the request. So for example, we can do this, get JSON, and it will return the body of the request as a Python dictionary. So it will take the body of the request, it will assume that it's JSON, it will parse it, and it will turn it into a Python dictionary. And so it will now return it as a customer. Our response is also JSON. So we need to prepare our response. So it will be, let's say, churn probability and our y pret. And maybe also because our web service will now need to make a decision whether they want to send a promotional email or not. Marketing service doesn't really know if we should use 0 .5 as threshold or 0 .75 or 0 .9. It doesn't know. So we don't want marketing service to decide that. So we want to make this decision here in our churn service. Let's make this decision. Churn, and we'll use the 0 .5 threshold. So it will be true if it's above 0 .5 and false or otherwise. So we want to return that. So now this is a Python dictionary and we want to turn this into JSON. And for that, there is another helpful function in Flask called JSONify. 

We now just invoke this function and return the result. Yeah, so it's a little bit more complex than the pink function we had here. So this is our core logic, turning a customer into a feature matrix, then invoking a model, and then deciding if this customer is going to churn or not. We actually probably want to put this logic in a separate function. I will not do it here, but for a real project, I would put this away inside a separate function. So here we have only some weather plate code, like getting the customer from JSON and then JSONify the result. And the core logic will be inside a different function. I'll keep it here like that. 

So let's just test it. I think here we will now have an error, and I just want you to see this error before we fix it. So let's run it. So we have this Python predict. So it run our application and it is available. So now we want to communicate with this web service. So now let's pretend we're this marketing service, and we will pretend from a Jupyter notebook. So let me just create a new notebook. 

I'll call it 0 .5 predict test. So from this notebook, we want to communicate with our churn prediction service. And remember previously with this ping pong service, we could just do this from our browser. Here it's not the case, because in the browser, when you enter like 696 predict, it will now say method is not allowed, because a browser is sending a get request. So you can see this in the logs. So the browser is trying to get a get request. But it says 405, meaning the method is not allowed. The only allowed method here is post. So we need to send a post request. And from the browser, it's not easy. So what we want to do is we want to do it from Python. And for that, there is a great library called requests. So we'll use that. Let's say our URL is http localhost 9696 predict. Let's take our customer. Customer we want to send. I think I saved this customer here. So this is our customer. By the way, as you see, JSON here turned out to be a valid Python dictionary. So we have this customer here. So what we want to do now is we want to send this customer in a post request. So for that, we use requests. And then there is a function called posts. And then it needs a URL, this URL. And we say that we want to send this dictionary as JSON. Now you see the response with 500. So this is an error. So and remember, I told you that there will be an error. And I want you to see this error. So it says object of type bool is not JSON serializable. It could be quite confusing. And the reason for that is this bool underscore is something that is coming from NumPy. But the JSON class in Python, so see this JSON, doesn't know how to turn the objects of this class into text. But it knows how to turn usual Python booleans into text. So we need to do now is wrap this churn into boolean. So this will turn the NumPy boolean into a usual Python boolean. And this ypret is also, I think, from NumPy. So this is a float 64, I think. So we need to turn it into a Python float. So we save now. And because we run our flask in debug mode, it detected the change in this file. And it reloaded the web service. So now we don't need to stop it. We don't need to start it again. It automatically restarted it. Now let's invoke it again. And now the response is 200, meaning that it was successful. And we see this in the logs as well. So there was a post request to slash predict. It ended up being successful, 200. Don't see the content, the body of the response here. We know that this is JSON. So we can just use this dot JSON thing that will take the content of the request and turn it into a Python dictionary. And this is what we have. So this is what we send back from the service. This is our response. And we are able to get this response from the service. Let's say if we're the marketing service, we can do something like if response churn is true, then send in from email to customer ID. I don't think we have a customer ID. Let's say XYZ123. Of course, it doesn't know what is that. But this is customer ID. And if here we have tenor, 24 months, then the response, yeah, I think we also need to adjust that. Total charges because it would be 24 times more. Yeah, so you see that the customer is not churning. So we are not sending a promotional email to this customer. This is how we turned our predict script into a web service. So let me just stop it and start it again. When we do this, we see that warning. This is a development service. Do not use it in production deployment. Use it in production VSGI service. If you were wondering what to do in this case, so what we need to do here is instead of using plain flask, we need to use, basically it says what we need to use, VSGI server instead. There are many different VSGI servers available in Python. I usually use gunicorn. We need to install it first. I installed it previously. So that's why it uses a cached version. So I didn't need to download it. But yeah, so now it installed it again. The way we use gunicorn is we use it in gunicorn. So we need to tell gunicorn where our flask app is. Our flask app is in predict app. So this thing here means that our app is here. So use that. The Python file where it needs to go is predict .py. So we write predict and the variable it is interested in is app. And then we also need to specify, so we don't need to run here. Yeah, we just need to predict app. And we also need to specify the address where this thing will live here. This thing here will not be executed because we put it inside this if statement. So that's why here we have debug true. But it doesn't matter for gunicorn because this line will not be executed when we run it from gunicorn. So this is what we do. Gunicorn, bind, then the address, and then the location for app. And we run it this way. So here you don't see any warnings because gunicorn is designed for production. And we can test it. So it returns the same thing. So this is how you turn a flask app into something production ready. And this is what we will next use for deploying our services. I know that many of you are using Windows. I actually also use Windows, as you can see. This is a Linux subsystem. If you're using plain Windows, gunicorn will not work. So gunicorn uses some Linux or Unix specific features. So it works on macOS. It works on Linux. But it doesn't work on Windows. So if you try to run, just try to install it as well. pip install. I don't know if I have flask on Windows. Flask gunicorn. 

So now I have flask. I have gunicorn. So let me go to this zoom .com directory. So this is the same directory we used in this tab. It's the same one. So now if I, let me just go copy this. 

If I run that, it will say no module name fcntl. I have no idea what is that. If you try to Google this, you will find out that the reason for that is because gunicorn does not support Windows. So if you're on Windows and you don't want to install the subsystem for Linux, which I recommend doing, you should definitely do this if you're on Windows. But if for some reasons you do not want to do this, you can use an alternative. It's called waitress. install waitress. It's very similar to gunicorn. Let's install it. And then you use it very similarly to gunicorn. Let me just get gunicorn. Place it with waitress. And instead of bind, I think we need to use something else. Let me quickly Google it. 

Instead of writing gunicorn, we write waitress serve. And then we write listen instead of bind. So waitress. 

Show listen 0009696. 

And then again, predict up. 

Yeah, so I have these weird warnings. So the Windows I have here is a bit special because it's actually a tablet. It's not a real Windows computer. I think that's why I have these weird warnings. I'm not really sure why I have this. That's why please ignore them. But there is not actually a weird warning. More important warning says that it's trying to unpick an estimator logistic regression from version 0 .24 .2 using version of scikit -learn 1 .0. And the reason for that is because I installed scikit -learn on my Windows system just yesterday when scikit -learn was already at 0 .1 version. But for my Linux, I installed it a month ago or something like this. So it's the version before. And scikit -learn complains about that. So it says, hey, be careful. The version of scikit -learn that I use here is different. That's why use your estimators at your own risk because the code for the estimators might have changed between versions. It's not actually safe. That's why there is this warning. Okay, so I cannot really now use this notebook to test this because this notebook lives in my Linux and this service is running on Windows. So what I'm going to do is I will save this again as a file. It's a Python file. And I will put this file into our folder. Rename it as predict test. It's probably a name. I will just remove 0 .5 at the beginning. And let me open it with VS Code. So I'll do a bit of cleaning here. Here we have the customer here. And we have the response. So what I want to do is I just want to print the response. So print that not sending a promotion. And customer ID. Let's just write it here. Customer ID is XYZ123. 

Put it here. Okay, so we have this code now. And cleaned it a little bit. So now let's run this. So we have another command prompt. So I'm in the same directory. So I need to run predict test. So now it was able to communicate with Waitress with this process and get back the predictions. Okay, I think that's it for this lesson. This lesson we turned our predict .py script into a Flask application. And then we saw how to query it with requests. Then we put it in a production ready VSGI server, which is GUnicorn. And then we saw how to also do this on Windows using Waitress. So now we have our service ready. And in the next lesson, we will talk about dependency in environment management. If one project uses scikit -learn of one version and another project uses a scikit -learn of a different version, they need to live together on one computer. So in the next lesson, we will see how to achieve that. So see you soon. 